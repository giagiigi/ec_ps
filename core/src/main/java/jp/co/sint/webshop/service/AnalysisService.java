package jp.co.sint.webshop.service;

import java.io.Reader;
import java.util.Date;
import java.util.List;

import jp.co.sint.webshop.data.SearchResult;
import jp.co.sint.webshop.service.analysis.AccessLogData;
import jp.co.sint.webshop.service.analysis.CommodityAccessLogSearchCondition;
import jp.co.sint.webshop.service.analysis.CommodityAccessLogSummary;
import jp.co.sint.webshop.service.analysis.CountType;
import jp.co.sint.webshop.service.analysis.CustomerGroupCampaignSummaryViewList;
import jp.co.sint.webshop.service.analysis.CustomerGroupCampaignSummaryViewSearchCondition;
import jp.co.sint.webshop.service.analysis.CustomerPreferenceSearchCondition;
import jp.co.sint.webshop.service.analysis.CustomerPreferenceSummary;
import jp.co.sint.webshop.service.analysis.CustomerStatisticsSummary;
import jp.co.sint.webshop.service.analysis.GiftCardUseLogSearchCondition;
import jp.co.sint.webshop.service.analysis.GiftCardUseLogSummary;
import jp.co.sint.webshop.service.analysis.NewPublicCouponSearchCondition;
import jp.co.sint.webshop.service.analysis.NewPublicCouponSummary;
import jp.co.sint.webshop.service.analysis.PlanSummaryViewInfo;
import jp.co.sint.webshop.service.analysis.PlanSummaryViewSearchCondition;
import jp.co.sint.webshop.service.analysis.RefererSearchCondition;
import jp.co.sint.webshop.service.analysis.RefererSummary;
import jp.co.sint.webshop.service.analysis.RfmAnalysisData;
import jp.co.sint.webshop.service.analysis.RfmAnalysisSearchCondition;
import jp.co.sint.webshop.service.analysis.SalesAmountByShopSearchCondition;
import jp.co.sint.webshop.service.analysis.SalesAmountByShopSummary;
import jp.co.sint.webshop.service.analysis.SalesAmountBySkuSearchCondition;
import jp.co.sint.webshop.service.analysis.SalesAmountBySkuSummary;
import jp.co.sint.webshop.service.analysis.SalesAmountSummary;
import jp.co.sint.webshop.service.analysis.SearchKeywordLogSearchCondition;
import jp.co.sint.webshop.service.analysis.SearchKeywordLogSummary;
import jp.co.sint.webshop.service.analysis.WeekGraphData;
import jp.co.sint.webshop.utility.DateRange;

/**
 * SI Web Shopping 10 分析サービス(AnalysisService)仕様
 * 
 * @author System Integrator Corp.
 */
public interface AnalysisService {

  /**
   * ログの保存期間を指定して期間外の商品別アクセスログの削除を行います。
   * <p>
   * <dl>
   * <dt><b>処理概要: </b></dt>
   * <dd>システム日付から引数で指定された月数だけ前の月の初日より前の商品別アクセスログを削除します。
   * <ol>
   * <li>引数で指定された保存月数が1以上であるかどうかチェックします。0以下であった場合はサービス処理結果にVALIDATION_ERRORを設定します。</li>
   * <li> システム日付の引数で指定された月数前の月の初日をログが残される最も前の日付とします。
   * 例：システム日付が2008/04/13で引数の値が3であれば2008/01の初日、つまり2008/01/01となります。 </li>
   * <li>トランザクションを開始します。</li>
   * <li>商品別アクセスログのアクセス日が2.で指定された日よりも前のレコードをDELETEします。</li>
   * <li>トランザクションをCOMMITしサービス処理結果を返します。</li>
   * </ol>
   * </dd>
   * </dl>
   * </p>
   * <p>
   * <dl>
   * <dt><b>前提条件: </b></dt>
   * <dd>keepingMonthが1以上であること。</dd>
   * </dl>
   * </p>
   * <p>
   * <dl>
   * <dt><b>事後条件: </b></dt>
   * <dd>商品別アクセスログのアクセス日が指定日より前のレコードが全て物理削除されます。</dd>
   * </dl>
   * </p>
   * 
   * @param keepingMonth
   *          ログを保存する期間(月単位)です。
   * @return サービス処理結果です。
   */
  ServiceResult deleteCommodityAccessLog(int keepingMonth);

  /**
   * ログの保存期間を指定して期間外のアクセスログの削除を行います。
   * <p>
   * <dl>
   * <dt><b>処理概要: </b></dt>
   * <dd>システム日付から引数で指定された月数だけ前の月の初日より前のアクセスログを削除します。
   * <ol>
   * <li>引数で指定された保存月数が1以上であるかどうかチェックします。0以下であった場合はサービス処理結果にVALIDATION_ERRORを設定します。</li>
   * <li> システム日付の引数で指定された月数前の月の初日をログが残される最も前の日付とします。
   * 例：システム日付が2008/04/13で引数の値が3であれば2008/01の初日、つまり2008/01/01となります。 </li>
   * <li>トランザクションを開始します。</li>
   * <li>アクセスログテーブルのアクセス日が2.で指定された日よりも前のレコードをDELETEします。</li>
   * <li>トランザクションをCOMMITしサービス処理結果を返します。</li>
   * </ol>
   * </dd>
   * </dl>
   * </p>
   * <p>
   * <dl>
   * <dt><b>前提条件: </b></dt>
   * <dd>keepingMonthが1以上であること。</dd>
   * </dl>
   * </p>
   * <p>
   * <dl>
   * <dt><b>事後条件: </b></dt>
   * <dd>アクセスログテーブルのアクセス日が指定日より前のレコードが全て物理削除されます。</dd>
   * </dl>
   * </p>
   * 
   * @param keepingMonth
   *          ログを保存する期間(月単位)です。
   * @return サービス処理結果です。
   */
  ServiceResult deleteCustomerAccessLog(int keepingMonth);

  /**
   * ログの保存期間を指定して期間外のリファラーログの削除を行います。
   * <p>
   * <dl>
   * <dt><b>処理概要: </b></dt>
   * <dd>システム日付から引数で指定された月数だけ前の月の初日より前のリファラーログを削除します。
   * <ol>
   * <li>引数で指定された保存月数が1以上であるかどうかチェックします。0以下であった場合はサービス処理結果にVALIDATION_ERRORを設定します。</li>
   * <li> システム日付の引数で指定された月数前の月の初日をログが残される最も前の日付とします。
   * 例：システム日付が2008/04/13で引数の値が3であれば2008/01の初日、つまり2008/01/01となります。 </li>
   * <li>トランザクションを開始します。</li>
   * <li>リファラーログのアクセス日が2.で指定された日よりも前のレコードをDELETEします。</li>
   * <li>トランザクションをCOMMITしサービス処理結果を返します。</li>
   * </ol>
   * </dd>
   * </dl>
   * </p>
   * <p>
   * <dl>
   * <dt><b>前提条件: </b></dt>
   * <dd>keepingMonthが1以上であること。</dd>
   * </dl>
   * </p>
   * <p>
   * <dl>
   * <dt><b>事後条件: </b></dt>
   * <dd>リファラーログのアクセス日が指定日より前のレコードが全て物理削除されます。</dd>
   * </dl>
   * </p>
   * 
   * @param keepingMonth
   *          ログを保存する期間(月単位)です。
   * @return サービス処理結果です。
   */
  ServiceResult deleteReferer(int keepingMonth);

  /**
   * ログの保存期間を指定して期間外の検索キーワードログの削除を行います。
   * <p>
   * <dl>
   * <dt><b>処理概要: </b></dt>
   * <dd>システム日付から引数で指定された月数だけ前の月の初日より前の検索キーワードログを削除します。
   * <ol>
   * <li>引数で指定された保存月数が1以上であるかどうかチェックします。0以下であった場合はサービス処理結果にVALIDATION_ERRORを設定します。</li>
   * <li> システム日付の引数で指定された月数前の月の初日をログが残される最も前の日付とします。
   * 例：システム日付が2008/04/13で引数の値が3であれば2008/01の初日、つまり2008/01/01となります。 </li>
   * <li>トランザクションを開始します。</li>
   * <li>検索キーワードログテーブルの検索日が2.で指定された日よりも前のレコードをDELETEします。</li>
   * <li>トランザクションをCOMMITしサービス処理結果を返します。</li>
   * </ol>
   * </dd>
   * </dl>
   * </p>
   * <p>
   * <dl>
   * <dt><b>前提条件: </b></dt>
   * <dd>keepingMonthが1以上であること。</dd>
   * </dl>
   * </p>
   * <p>
   * <dl>
   * <dt><b>事後条件: </b></dt>
   * <dd>検索キーワードログテーブルの検索日が指定日より前のレコードが全て物理削除されます。</dd>
   * </dl>
   * </p>
   * 
   * @param keepingMonth
   *          ログを保存する期間(月単位)です。
   * @return サービス処理結果です。
   */
  ServiceResult deleteSearchKeywordLog(int keepingMonth);

  /**
   * ログの保存期間を指定して期間外の管理側アクセスログの削除を行います。
   * <p>
   * <dl>
   * <dt><b>処理概要: </b></dt>
   * <dd>システム日付から引数で指定された月数だけ前の月の初日より前の管理側アクセスログを削除します。
   * <ol>
   * <li>引数で指定された保存月数が1以上であるかどうかチェックします。0以下であった場合はサービス処理結果にVALIDATION_ERRORを設定します。</li>
   * <li> システム日付の引数で指定された月数前の月の初日をログが残される最も前の日付とします。
   * 例：システム日付が2008/04/13で引数の値が3であれば2008/01の初日、つまり2008/01/01となります。 </li>
   * <li>トランザクションを開始します。
   * <li>管理側アクセスログテーブルのアクセス日時が1.で指定した日よりも前のレコードをDELETEします。</li>
   * <li>トランザクションをCOMMITしサービス処理結果を返します。</li>
   * </ol>
   * </dd>
   * </dl>
   * </p>
   * <p>
   * <dl>
   * <dt><b>前提条件: </b></dt>
   * <dd>keepingMonthが1以上であること。</dd>
   * </dl>
   * </p>
   * <p>
   * <dl>
   * <dt><b>事後条件: </b></dt>
   * <dd>管理側アクセスログテーブルのアクセス日時が指定日より前のレコードが全て物理削除されます。</dd>
   * </dl>
   * </p>
   * 
   * @param keepingMonth
   *          ログを保存する期間(月単位)です。
   * @return サービス処理結果です。
   */
  ServiceResult deleteUserAccessLog(int keepingMonth);

  /**
   * 集計期間を指定して顧客嗜好分析に使用するデータの作成を行います。
   * <p>
   * <dl>
   * <dt><b>処理概要: </b></dt>
   * <dd>受注ヘッダ、受注明細、顧客の各テーブルを参照し、顧客嗜好分析に使用するデータの作成を行います。
   * <ol>
   * <li>引数のチェックを行います。0以下である場合はサービス処理結果にVALIDATION_ERRORを設定します。</li>
   * <li>システム日付の引数で指定された月数だけ前の月の初日を集計開始日、システム日付の月の末日を集計終了日とします。</li>
   * <li>トランザクションを開始します。</li>
   * <li>顧客嗜好テーブルの購入年月カラムが集計対象期間内であるレコードをDELETEします。</li>
   * <li>受注ヘッダ、受注明細、顧客の各テーブルを結合し、集計対象期間内の合計受注回数、合計購入商品数を
   * ショップコード、商品コード、顧客コード、受注年月、顧客グループコード、ショップ名、商品名、年齢、性別ごとに集計します。</li>
   * <li>5．で集計した結果を顧客嗜好分析テーブルにINSERTします。</li>
   * <li>トランザクションをCOMMITし、サービス実行結果を返します。</li>
   * </ol>
   * </dd>
   * </dl>
   * </p>
   * <p>
   * <dl>
   * <dt><b>前提条件: </b></dt>
   * <dd>monthが1以上であること。</dd>
   * </dl>
   * </p>
   * <p>
   * <dl>
   * <dt><b>事後条件: </b></dt>
   * <dd>顧客嗜好テーブルの集計年月が対象期間内であるレコードが更新されます。</dd>
   * <dd>集計結果のレコードが存在しない場合は、顧客嗜好テーブルの集計年月が集計対象期間内であるレコードは0件になります。</dd>
   * <dd>データベース処理中に例外が発生した場合はトランザクションがROLLBACKされ、サービス処理結果にDB_OBJECT_EXECUTE_ERRORを設定します。</dd>
   * </dl>
   * </p>
   * 
   * @param month
   *          集計期間(月単位)です。
   * @return サービス処理結果です。
   */
  ServiceResult generateCustomerPreference(int month);

  /**
   * 顧客分析に使用するデータの作成を行います。
   * <p>
   * <dl>
   * <dt><b>処理概要: </b></dt>
   * <dd>顧客、顧客グループ、顧客属性の各テーブルを参照し顧客分析に使用するデータの作成を行います。
   * <ol>
   * <li>トランザクションを開始します。</li>
   * <li>顧客分析テーブルのレコードを全件DELETEします。
   * <li>顧客、顧客グループ、顧客属性の各テーブルを結合し、顧客グループごと、性別ごと、年齢ごと、 各顧客属性ごとにそれぞれ顧客の人数を集計します。
   * </li>
   * <li>3.で集計した結果を顧客分析テーブルにINSERTします。</li>
   * <li>トランザクションをCOMMITし、サービス実行結果を返します。</li>
   * </ol>
   * </dd>
   * </dl>
   * </p>
   * <p>
   * <dl>
   * <dt><b>前提条件: </b></dt>
   * <dd>ありません。</dd>
   * </dl>
   * </p>
   * <p>
   * <dl>
   * <dt><b>事後条件: </b></dt>
   * <dd>顧客分析テーブルが更新されます。</dd>
   * <dd>集計結果のレコードが存在しない場合は顧客分析テーブルのレコードは0件になります。</dd>
   * <dd>データベース処理中に例外が発生した場合はトランザクションをROLLBACKし、サービス処理結果にDB_OBJECT_EXECUTE_ERRORを設定します。</dd>
   * </dl>
   * </p>
   * 
   * @return サービス処理結果です。
   */
  ServiceResult generateCustomerStatistics();

  /**
   * RFM分析に使用するデータを作成します。
   * <p>
   * <dl>
   * <dt><b>処理概要: </b></dt>
   * <dd>受注ヘッダ、受注明細の各テーブルを参照しRFM分析に使用するデータの作成を行います。
   * <ol>
   * <li>トランザクションを開始します。</li>
   * <li>RFMテーブルのレコードを全件DELETEします。</li>
   * <li>受注ヘッダ、受注詳細の各テーブルを結合し、受注番号、受注日、顧客コードごとに合計購入商品数、合計購入金額を集計します。</li>
   * <li>3. で集計した結果をRFMテーブルにINSERTします。</li>
   * <li>トランザクションをCOMMITし、サービス実行結果を返します。</li>
   * </ol>
   * </dd>
   * </dl>
   * </p>
   * <p>
   * <dl>
   * <dt><b>前提条件: </b></dt>
   * <dd>ありません。</dd>
   * </dl>
   * </p>
   * <p>
   * <dl>
   * <dt><b>事後条件: </b></dt>
   * <dd>集計結果でRFMテーブルが更新されます。</dd>
   * <dd>受注ヘッダと受注明細のいずれかのテーブルにレコードが存在しない場合は、RFMテーブルのレコードは0件になります。</dd>
   * <dd>データベース処理中に例外が発生した場合はトランザクションをROLLBACKし、サービス処理結果にDB_OBJECT_EXECUTE_ERRORを設定します。</dd>
   * </dl>
   * </p>
   * 
   * @return サービス処理結果です。
   */
  ServiceResult generateRfm();

  /**
   * 日付を指定して、RFM分析に使用するデータを作成します。
   * <p>
   * <dl>
   * <dt><b>処理概要: </b></dt>
   * <dd>受注ヘッダ、受注明細の各テーブルを参照しRFM分析に使用するデータの作成を行います。
   * <ol>
   * <li>引数のnullチェックを行います。nullであった場合はサービス処理結果にVALIDATION_ERRORを設定します。
   * <li>トランザクションを開始します。</li>
   * <li>RFMテーブルの受注日が引数で指定された日であるレコードをDELETEします。</li>
   * <li>受注ヘッダ、受注明細の各テーブルを結合し、受注日が引数で指定された日付である受注について
   * 受注番号、受注日、顧客コードごとに合計購入商品数、合計購入金額を集計します。</li>
   * <li>4. で集計した結果をRFMテーブルにINSERTします。</li>
   * <li>トランザクションをCOMMITし、サービス実行結果を返します。</li>
   * </ol>
   * </dd>
   * </dl>
   * </p>
   * <p>
   * <dl>
   * <dt><b>前提条件: </b></dt>
   * <dd>targetDayがnullでないこと。</dd>
   * </dl>
   * </p>
   * <p>
   * <dl>
   * <dt><b>事後条件: </b></dt>
   * <dd>RFMテーブルの受注日が引数で指定された日付であるレコードが更新されます。</dd>
   * <dd>受注ヘッダ、受注明細のいずれかのテーブルに受注日が指定された日付であるレコードが存在しない場合はRFMテーブルの受注日が指定された日付であるレコードは0件になります。</dd>
   * <dd>データベース処理中に例外が発生した場合はトランザクションをROLLBACKし、サービス処理結果にDB_OBJECT_EXECUTE_ERRORを設定します。</dd>
   * </dl>
   * </p>
   * 
   * @return サービス処理結果です。
   */
  ServiceResult generateRfm(Date targetDay);

  /**
   * 期間を指定して、RFM分析に使用するデータを作成します。
   * <p>
   * <dl>
   * <dt><b>処理概要: </b></dt>
   * <dd>受注ヘッダ、受注明細の各テーブルを参照しRFM分析に使用するデータの作成を行います。
   * <ol>
   * <li>引数のバリデーションチェックを行います。バリデーションエラーの場合は、サービス処理結果にVALIDATION_ERRORを設定します。</li>
   * <li>トランザクションを開始します。</li>
   * <li>RFMテーブルの受注日が引数で指定された期間内であるレコードをDELETEします。</li>
   * <li>受注ヘッダ、受注明細の各テーブルを参照し、受注日が引数で指定された期間内であるレコードについて
   * 受注番号、受注日、顧客コードごとに合計購入商品数、合計購入金額を集計します。</li>
   * <li>4. で集計した結果をRFMテーブルにINSERTします。</li>
   * <li>トランザクションをCOMMITし、サービス実行結果を返します。</li>
   * </ol>
   * </dd>
   * </dl>
   * </p>
   * <p>
   * <dl>
   * <dt><b>前提条件: </b></dt>
   * <dd>periodがnullでないこと。</dd>
   * <dd>periodのstartとendのいずれもnullでないこと。</dd>
   * </dl>
   * </p>
   * <p>
   * <dl>
   * <dt><b>事後条件: </b></dt>
   * <dd>集計結果でRFMテーブルの受注日が指定期間であるレコードが更新されます。</dd>
   * <dd>受注ヘッダ、受注明細のいずれかのテーブルに受注日が引数で指定された期間内であるレコードが存在しない場合は
   * RFMテーブルの受注日が引数で指定された期間内であるレコードは0件になります。</dd>
   * <dd>データベース処理中に例外が発生した場合はトランザクションをROLLBACKし、サービス処理結果にDB_OBJECT_EXECUTE_ERRORが設定されます。</dd>
   * </dl>
   * </p>
   * 
   * @return サービス処理結果です。
   */
  ServiceResult generateRfm(DateRange period);

  /**
   * ショップ別売上集計に使用するデータを作成します。
   * <p>
   * <dl>
   * <dt><b>処理概要: </b></dt>
   * <dd>受注ヘッダ、出荷ヘッダ、出荷明細、ショップの各テーブルを参照し、ショップ別売上集計に使用するデータの作成を行います。
   * <ol>
   * <li>トランザクションを開始します。</li>
   * <li>ショップ別売上集計テーブルのレコードをDELETEします。</li>
   * <li> 受注ヘッダ、出荷ヘッダ、出荷明細、ショップの各テーブルを参照し、
   * 出荷日、ショップコード、クライアントグループ、支払い方法番号、ショップ名ごとに 売上合計、消費税額合計、受注回数、値引き額合計、使用ポイント額合計、
   * 発行ポイント額合計、支払い方法手数料合計、支払い方法手数料消費税金額合計、配送手数料額合計、配送手数料消費税額合計、ギフト金額合計、
   * ギフト金額消費税額合計、返金金額合計、返金金額消費税額合計、返品商品損金額合計、返品商品数合計をそれぞれ集計します。 </li>
   * <li>3.で集計した結果をショップ別売上集計テーブルにINSERTします。このとき、出荷日を集計日とします。 </li>
   * <li>トランザクションをCOMMITし、サービス処理結果を返します。</li>
   * </ol>
   * </dd>
   * </dl>
   * </p>
   * <p>
   * <dl>
   * <dt><b>前提条件: </b></dt>
   * <dd>ありません。</dd>
   * </dl>
   * </p>
   * <p>
   * <dl>
   * <dt><b>事後条件: </b></dt>
   * <dd>ショップ別売上集計テーブルの全レコードが再作成されます。</dd>
   * <dd>受注ヘッダ、出荷ヘッダ、出荷明細、ショップのいずれかのテーブルにレコードが存在しない場合は
   * ショップ別売上集計テーブルのレコードは0件になります。</dd>
   * <dd>データベース処理中に例外が発生した場合は、サービス処理結果にDB_OBJECT_EXECUTE_ERRORを設定します。</dd>
   * </dl>
   * </p>
   * 
   * @return サービス処理結果です。
   */
  ServiceResult generateSalesAmountByShop();

  /**
   * 日付を指定してショップ別売上集計に使用するデータを作成します。
   * <p>
   * <dl>
   * <dt><b>処理概要: </b></dt>
   * <dd>受注ヘッダ、出荷ヘッダ、出荷明細、ショップの各テーブルを参照し、ショップ別売上集計に使用するデータの作成を行います。
   * <ol>
   * <li>引数のnullチェックを行います。nullであった場合はサービス処理結果にVALIDATION_ERRORを設定します。</li>
   * <li>トランザクションを開始します。</li>
   * <li>ショップ別売上集計テーブルの集計日が引数で指定された日であるレコードをDELETEします。</li>
   * <li>
   * 受注ヘッダ、出荷ヘッダ、出荷明細、ショップの各テーブルを結合し、出荷日が引数で指定された日であるレコードを出荷日、ショップコード、クライアントグループ、支払い方法番号、ショップ名ごとに売上合計、消費税額合計、受注回数、値引き額合計、使用ポイント額合計、
   * 発行ポイント額合計、支払い方法手数料合計、支払い方法手数料消費税金額合計、配送手数料額合計、配送手数料消費税額合計、ギフト金額合計、
   * ギフト金額消費税額合計、返金金額合計、返金金額消費税額合計、返品商品損金額合計、返品商品数合計をそれぞれ集計します。 </li>
   * <li>4.で集計した結果をショップ別売上集計テーブルにINSERTします。このとき、出荷日を集計日とします。 </li>
   * <li>トランザクションをCOMMITし、サービス処理結果を返します。</li>
   * </ol>
   * </dd>
   * </dl>
   * </p>
   * <p>
   * <dl>
   * <dt><b>前提条件: </b></dt>
   * <dd>countedDateがnullでないこと。</dd>
   * </dl>
   * </p>
   * <p>
   * <dl>
   * <dt><b>事後条件: </b></dt>
   * <dd>ショップ別売上集計の集計日が引数で指定された日であるレコードが再作成されます。</dd>
   * <dd>受注ヘッダ、出荷ヘッダ、出荷明細、ショップのいずれかのテーブルに出荷日が引数で指定された日である
   * レコードが存在しない場合はショップ別売上集計テーブルの集計日が引数で指定された日であるレコードは0件になります。</dd>
   * <dd>データベース処理中に例外が発生した場合は、サービス処理結果にDB_OBJECT_EXECUTE_ERRORを設定します。</dd>
   * </dl>
   * </p>
   * 
   * @param countedDate
   *          集計を行う日付です。
   * @return サービス処理結果です。
   */
  ServiceResult generateSalesAmountByShop(Date countedDate);

  /**
   * 期間を指定してショップ別売上集計に使用するデータを作成します。
   * <p>
   * <dl>
   * <dt><b>処理概要: </b></dt>
   * <dd>受注ヘッダ、出荷ヘッダ、出荷明細、ショップの各テーブルを参照し、ショップ別売上集計に使用するデータの作成を行います。
   * <ol>
   * <li>引数のバリデーションチェックを行います。バリデーションエラーの場合はサービス処理結果にVALIDATION_ERRORを設定します。</li>
   * <li>トランザクションを開始します。</li>
   * <li>ショップ別売上集計テーブルの集計日が引数で指定された範囲内にあるレコードをDELETEします。</li>
   * <li> 受注ヘッダ、出荷ヘッダ、出荷明細、ショップの各テーブルを結合し 出荷日が引数で指定された範囲内であるであるレコードについて
   * 出荷日、ショップコード、クライアントグループ、支払い方法番号、ショップ名ごとに売上合計、消費税額合計、受注回数、値引き額合計、使用ポイント額合計、
   * 発行ポイント額合計、支払い方法手数料合計、支払い方法手数料消費税金額合計、配送手数料額合計、配送手数料消費税額合計、ギフト金額合計、
   * ギフト金額消費税額合計、返金金額合計、返金金額消費税額合計、返品商品損金額合計、返品商品数合計をそれぞれ集計します。 </li>
   * <li>4.で集計した結果をショップ別売上集計テーブルにINSERTします。このとき、出荷日を集計日とします。 </li>
   * <li>トランザクションをCOMMITし、サービス処理結果を返します。</li>
   * </ol>
   * </dd>
   * </dl>
   * </p>
   * <p>
   * <dl>
   * <dt><b>前提条件: </b></dt>
   * <dd>periodがnullでないこと。</dd>
   * <dd>periodのstart、endが共にnullでないこと。</dd>
   * </dl>
   * </p>
   * <p>
   * <dl>
   * <dt><b>事後条件: </b></dt>
   * <dd>ショップ別売上集計テーブルの集計日が指定期間内であるレコードが再作成されます。</dd>
   * <dd>受注ヘッダ、出荷ヘッダ、出荷明細、ショップのいずれかのテーブルにレコードが
   * 存在しない場合はショップ別売上集計の集計日が引数で指定された範囲内で あるレコードは0件になります。</dd>
   * <dd>データベース処理中に例外が発生した場合は、サービス処理結果にDB_OBJECT_EXECUTE_ERRORを設定します。</dd>
   * </dl>
   * </p>
   * 
   * @param period
   *          集計を行う期間です。
   * @return サービス処理結果です。
   */
  ServiceResult generateSalesAmountByShop(DateRange period);

  /**
   * SKU別売上集計に使用するデータの作成を行います。
   * <p>
   * <dl>
   * <dt><b>処理概要: </b></dt>
   * <dd>出荷ヘッダ、出荷明細、受注ヘッダ、ショップ、商品ヘッダ、商品明細の各テーブルを参照してSKU別売上集計に使用するデータの作成を行います。
   * <ol>
   * <li>トランザクションを開始します。</li>
   * <li>SKU別売上集計テーブルの全レコードをDELETEします。</li>
   * <li>出荷ヘッダ、出荷明細、受注ヘッダ、ショップ、商品ヘッダ、商品明細の各テーブルを結合し、
   * 出荷日がnullでなく出荷ステータスが出荷済みであるレコードについて
   * 出荷日、ショップコード、SKUコード、商品コード、ショップ名、SKU名ごとに売上金額合計、売上数量、
   * 値引き額累計、ギフト金額合計、ギフト消費税額合計を集計します。
   * 売上金額消費税累計、返金額累計、返金額消費税累計、返品個数累計については0に設定しておきます。
   * <dl>
   * <dt> SKU名 </dt>
   * <dd>対象の商品に規格1と規格2が存在するとき･･･商品名(規格名1/規格名2)</dd>
   * <dd>対象の商品に規格1が存在し規格2が存在しないとき･･･商品名(規格名1)</dd>
   * <dd>対象の商品に規格1が存在せず規格2が存在するとき･･･商品名(規格名2)</dd>
   * <dd>対象の商品に規格1も規格2も存在しないとき･･･商品名</dd>
   * </dl>
   * </li>
   * <li>出荷ヘッダ、出荷明細、受注ヘッダ、ショップ、商品ヘッダ、商品明細の各テーブルを結合し、
   * 出荷日がnullでなく出荷ステータスが出荷済みかつ返品区分が返品であるレコードについて
   * 出荷日、ショップコード、SKUコード、商品コード、ショップ名、SKU名ごとに返金額累計、返品個数累計、 値引き額累計を集計します。 </li>
   * <li> 3.と4.で集計した結果のうち、出荷日、ショップコード、SKUコード、商品コード、ショップ名、SKU名が一致するレコードについては
   * 4.の結果で3.の返金額累計、返金額消費税累計、返品個数累計を更新します。 </li>
   * <li> 3.の結果と4.の一致しなかった部分の結果をSKU別売上集計テーブルにINSERTします。 </li>
   * <li> トランザクションをCOMMITし、サービス処理結果を返します。</li>
   * </ol>
   * </dd>
   * </dl>
   * </p>
   * <p>
   * <dl>
   * <dt><b>前提条件: </b></dt>
   * <dd>ありません。</dd>
   * </dl>
   * </p>
   * <p>
   * <dl>
   * <dt><b>事後条件: </b></dt>
   * <dd>SKU別売上集計テーブルの全レコードが再作成されます。
   * 出荷ヘッダ、出荷明細、受注ヘッダ、ショップ、商品ヘッダ、商品明細のいずれかのテーブルにレコードが存在しない場合は
   * SKU別売上集計テーブルのレコードは0件になります。 </dd>
   * <dd>データベース処理中に例外が発生した場合は、サービス処理結果にDB_OBJECT_EXECUTE_ERRORを設定します。</dd>
   * </dl>
   * </p>
   * 
   * @return サービス処理結果です。
   */
  ServiceResult generateSalesAmountBySku();

  /**
   * 集計日を指定してSKU別売上集計に使用するデータの作成を行います。
   * <p>
   * <dl>
   * <dt><b>処理概要: </b></dt>
   * <dd>出荷ヘッダ、出荷明細、受注ヘッダ、ショップ、商品ヘッダ、商品明細の各テーブルを参照してKU別売上集計に使用するデータの作成を行います。
   * <ol>
   * <li>引数のnullチェックを行います。nullであった場合はサービス処理結果にVALIDATION_ERRORが設定されます。</li>
   * <li>トランザクションを開始します。</li>
   * <li>SKU別売上集計テーブルの全レコードをDELETEします。</li>
   * <li>出荷ヘッダ、出荷明細、受注ヘッダ、ショップ、商品ヘッダ、商品明細の各テーブルを結合し、
   * 出荷日がnullでなく出荷ステータスが出荷済みであり、出荷日が引数で指定された日付であるレコードについて
   * 出荷日、ショップコード、SKUコード、商品コード、ショップ名、SKU名ごとに売上金額合計、売上数量、
   * 値引き額累計、ギフト金額合計、ギフト消費税額合計を集計します。
   * 売上金額消費税累計、返金額累計、返金額消費税累計、返品個数累計については0に設定しておきます。
   * <dl>
   * <dt> SKU名 </dt>
   * <dd>対象の商品に規格1と規格2が存在するとき･･･商品名(規格名1/規格名2)</dd>
   * <dd>対象の商品に規格1が存在し規格2が存在しないとき･･･商品名(規格名1)</dd>
   * <dd>対象の商品に規格1が存在せず規格2が存在するとき･･･商品名(規格名2)</dd>
   * <dd>対象の商品に規格1も規格2も存在しないとき･･･商品名</dd>
   * </dl>
   * </li>
   * <li>出荷ヘッダ、出荷明細、受注ヘッダ、ショップ、商品ヘッダ、商品明細の各テーブルを結合し、
   * 出荷日がnullでなく出荷ステータスが出荷済みかつ返品区分が返品であり出荷日が引数で指定された日付であるレコードについて
   * 出荷日、ショップコード、SKUコード、商品コード、ショップ名、SKU名ごとに返金額累計、返品個数累計、 値引き額累計を集計します。 </li>
   * <li> 4.と5.で集計した結果のうち、出荷日、ショップコード、SKUコード、商品コード、ショップ名、SKU名が一致するレコードについては
   * 5.の結果で4.の返金額累計、返金額消費税累計、返品個数累計を更新します。 </li>
   * <li> 4.の結果と5.の一致しなかった部分の結果をSKU別売上集計テーブルにINSERTします。 </li>
   * <li> トランザクションをCOMMITし、サービス処理結果を返します。</li>
   * </ol>
   * </dd>
   * </dl>
   * </p>
   * <p>
   * <dl>
   * <dt><b>前提条件: </b></dt>
   * <dd>countedDateがnullでないこと。</dd>
   * </dl>
   * </p>
   * <p>
   * <dl>
   * <dt><b>事後条件: </b></dt>
   * <dd>SKU別売上集計テーブルの集計日が引数で指定された日付であるレコードが再作成されます。
   * 出荷ヘッダ、出荷明細、受注ヘッダ、ショップ、商品ヘッダ、商品明細のいずれかのテーブルにレコードが存在しない場合は
   * SKU別売上集計テーブルのレコードは0件になります。 </dd>
   * <dd>データベース処理中に例外が発生した場合は、サービス処理結果にDB_OBJECT_EXECUTE_ERRORを設定します。</dd>
   * </dl>
   * </p>
   * 
   * @return サービス処理結果です。
   */
  ServiceResult generateSalesAmountBySku(Date countedDate);

  /**
   * 集計期間を指定してSKU別売上集計に使用するデータの作成を行います。
   * <p>
   * <dl>
   * <dt><b>処理概要: </b></dt>
   * <dd>出荷ヘッダ、出荷明細、受注ヘッダ、ショップ、商品ヘッダ、商品明細の各テーブルを参照してSKU別売上集計に使用するデータの作成を行います。
   * <ol>
   * <li>引数のバリデーションチェックを行います。バリデーションエラーであった場合はサービス処理結果にVALIDATION_ERRORが設定されます。</li>
   * <li>トランザクションを開始します。</li>
   * <li>SKU別売上集計テーブルの全レコードをDELETEします。</li>
   * <li>出荷ヘッダ、出荷明細、受注ヘッダ、ショップ、商品ヘッダ、商品明細の各テーブルを結合し、
   * 出荷日がnullでなく出荷ステータスが出荷済みであり、出荷日が引数で指定された期間内であるレコードについて
   * 出荷日、ショップコード、SKUコード、商品コード、ショップ名、SKU名ごとに売上金額合計、売上数量、
   * 値引き額累計、ギフト金額合計、ギフト消費税額合計を集計します。
   * 売上金額消費税累計、返金額累計、返金額消費税累計、返品個数累計については0に設定しておきます。
   * <dl>
   * <dt> SKU名 </dt>
   * <dd>対象の商品に規格1と規格2が存在するとき･･･商品名(規格名1/規格名2)</dd>
   * <dd>対象の商品に規格1が存在し規格2が存在しないとき･･･商品名(規格名1)</dd>
   * <dd>対象の商品に規格1が存在せず規格2が存在するとき･･･商品名(規格名2)</dd>
   * <dd>対象の商品に規格1も規格2も存在しないとき･･･商品名</dd>
   * </dl>
   * </li>
   * <li>出荷ヘッダ、出荷明細、受注ヘッダ、ショップ、商品ヘッダ、商品明細の各テーブルを結合し、
   * 出荷日がnullでなく出荷ステータスが出荷済みかつ返品区分が返品であり出荷日が引数で指定された期間内であるレコードについて
   * 出荷日、ショップコード、SKUコード、商品コード、ショップ名、SKU名ごとに返金額累計、返品個数累計、 値引き額累計を集計します。 </li>
   * <li> 4.と5.で集計した結果のうち、出荷日、ショップコード、SKUコード、商品コード、ショップ名、SKU名が一致するレコードについては
   * 5.の結果で4.の返金額累計、返金額消費税累計、返品個数累計を更新します。 </li>
   * <li> 4.の結果と5.の一致しなかった部分の結果をSKU別売上集計テーブルにINSERTします。 </li>
   * <li> トランザクションをCOMMITし、サービス処理結果を返します。</li>
   * </ol>
   * </dd>
   * </dl>
   * </p>
   * <p>
   * <dl>
   * <dt><b>前提条件: </b></dt>
   * <dd>periodがnullでないこと。</dd>
   * <dd>periodの開始日付、終了日付のいずれもnullでないこと。</dd>
   * <dd>periodの開始日付<=終了日付であること。</dd>
   * </dl>
   * </p>
   * <p>
   * <dl>
   * <dt><b>事後条件: </b></dt>
   * <dd>SKU別売上集計テーブルの集計日が引数で指定された期間内であるレコードが再作成されます。
   * 出荷ヘッダ、出荷明細、受注ヘッダ、ショップ、商品ヘッダ、商品明細のいずれかのテーブルにレコードが存在しない場合は
   * SKU別売上集計テーブルのレコードは0件になります。 </dd>
   * <dd>データベース処理中に例外が発生した場合は、サービス処理結果にDB_OBJECT_EXECUTE_ERRORを設定します。</dd>
   * </dl>
   * </p>
   * 
   * @return サービス処理結果です。
   */
  ServiceResult generateSalesAmountBySku(DateRange period);

  /**
   * 指定された期間、指定した単位でページビュー数とコンバージョン率をを計算した結果のリストを返します。
   * <p>
   * <dl>
   * <dt><b>処理概要: </b></dt>
   * <dd>指定された期間、指定した単位でコンバージョン率を計算した結果を返します。
   * <ol>
   * <li>検索条件のバリデーションチェックを行います。バリデーションエラーである場合は空のリストを返します。</li>
   * <li>typeがHOURLYの場合は引数で指定された年月日、DAILYの場合は引数で指定された年月、
   * EVERY_DAY_OF_WEEEKの場合は引数で指定された年月、MONTHLYの場合は引数で指定された年を検索期間とします。</li>
   * <li>typeがHOURLYの場合は時間帯、DAILYの場合は月の日、
   * EVERY_DAY_OF_WEEEKの場合は曜日、MONTHLYの場合は月を集計単位とします。。</li>
   * <li>アクセスログテーブルを検索期間、引数で指定されたクライアントグループで検索し、集計単位、クライアントグループごとにページビュー数を、集計単位ごとにコンバージョン率を計算します。</li>
   * <li>4.で作成されたデータをアクセスログのデータ格納クラスにセットし、返します。</li>
   * </ol>
   * </dd>
   * </dl>
   * </p>
   * <p>
   * <dl>
   * <dt><b>前提条件: </b></dt>
   * <dd>
   * <ol>
   * <dd>CountTypeがnullでないこと。</dd>
   * <dd>typeとyear,month,dayによって指定される検索期間が日付として正しいこと。
   * 例えば、type=EVERY_DAY_OF_WEEK、year=2008、month=13であった場合、
   * 検索期間が2008年13月となるため、日付として正しくありません。 </dd>
   * </ol>
   * </dd>
   * </dl>
   * </p>
   * <p>
   * <dl>
   * <dt><b>事後条件: </b></dt>
   * <dd>ありません。</dd>
   * </dl>
   * </p>
   * 
   * @param year
   *          検索する年です。typeに係らず使用されます。
   * @param month
   *          検索される月です。typeがHOURLY、DAILY、EVERY_DAY_OF_WEEKの場合使用されます。
   * @param day
   *          検索される日です。typeがHOURLYの場合使用されます。
   * @param clientGroup
   *          検索されるクライアントグループです。
   * @param type
   *          集計タイプです。集計期間、集計単位を決定します。
   * @return アクセスログ集計データです。ページビュー数のリストと、コンバージョン率のリストを持ちます。
   *         バリデーションエラーとなった場合は空のリストを返します。
   *         集計タイプ、集計単位ラベル、クライアントグループを渡すことで該当するページビュー数とコンバージョン率のデータを取得可能です。
   *         データが存在しなかった場合はページビュー数、コンバージョン率が0であるデータを作成し返します。
   */
  AccessLogData getAccessLog(CountType type, int year, int month, int day, String clientGroup);

  /**
   * 指定された条件で商品別アクセスログを検索し集計した結果のリストを返します。
   * <p>
   * <dl>
   * <dt><b>処理概要: </b></dt>
   * <dd>指定された条件で商品別アクセスログを検索し集計した結果のリストを返します。
   * <ol>
   * <li>検索条件のバリデーションチェックを行います。バリデーションエラーとなった場合は空のリストを返します。</li>
   * <li>指定された引数から検索条件を以下のように定めます。
   * <ul>
   * <li>アクセス日が指定された検索開始日から検索終了日の間である</li>
   * <li>アクセスしたクライアントが指定されたクライアントグループに属する</li>
   * <li>商品コードが指定された商品コードの範囲にある</li>
   * <li>商品名が指定された商品名と部分一致する</li>
   * <li>並び順は商品アクセス回数の降順</li>
   * </ul>
   * </li>
   * <li>2.で定めた検索条件で商品別アクセスログテーブルを検索し、ショップコード、商品コード、ショップ名、商品名ごとにアクセス回数を集計します。</li>
   * <li>3.で集計した結果のリストを返します。</li>
   * </ol>
   * </dd>
   * </dl>
   * </p>
   * <p>
   * <dl>
   * <dt><b>前提条件: </b></dt>
   * <dd>conditionの検索開始日がnullでないこと。</dd>
   * <dd>conditionの検索終了日がnullでないこと。</dd>
   * <dd>上記いずれかに反した場合、データベースアクセスを行わず、空のリストを返します。</dd>
   * </dl>
   * </p>
   * <p>
   * <dl>
   * <dt><b>事後条件: </b></dt>
   * <dd>ありません。</dd>
   * </dl>
   * </p>
   * 
   * @param condition
   *          検索条件です。ショップコード、検索開始日、検索終了日、クライアントグループ、検索開始商品コード、検索終了商品コード、商品名の各フィールドを持ちます。
   * @return 集計結果です。各要素はショップコード、商品コード、ショップ名、商品名、商品アクセス回数の各フィールドを持ちます。
   *         バリデーションエラーとなった場合は空のリストを返します。
   */
  SearchResult<CommodityAccessLogSummary> getCommodityAccessLog(CommodityAccessLogSearchCondition condition);

  /**
   * 検索条件から顧客嗜好分析結果を集計した結果のリストを返します。
   * <p>
   * <dl>
   * <dt><b>処理概要: </b></dt>
   * <dd>検索条件から顧客嗜好分析結果を集計した結果のリストを返します。
   * <ol>
   * <li>検索条件のバリデーションチェックを行います。バリデーションエラーとなった場合は空のリストを返します。</li>
   * <li>引数から検索条件を以下のように定めます。
   * <ul>
   * <li> ショップコードが指定されたショップコードと一致する </li>
   * <li> 受注日が指定された検索開始年月から検索終了年月の間である </li>
   * <li> 顧客グループが指定された顧客グループコードと一致する </li>
   * <li> 年齢が検索開始年齢から検索終了年齢の間である </li>
   * <li> 性別が指定した性別と一致する </li>
   * </ul>
   * </li>
   * <li>2.で定めた条件を元に顧客嗜好分析テーブルを検索し、集計を行い、ショップコード、ショップ名、商品コード、商品名ごとに購入顧客数、受注件数、受注件数構成率、累計購入個数を求めます。</li>
   * <li>3.で求めた結果のリストをconditionの並べ替えタイプに従ってソートしたものを返します。</li>
   * </ol>
   * </dd>
   * </dl>
   * </p>
   * <p>
   * <dl>
   * <dt><b>前提条件: </b></dt>
   * <dd>conditionの検索開始年がnullでないこと。</dd>
   * <dd>conditionの検索開始月がnullでないこと。</dd>
   * <dd>conditionの検索終了年がnullでないこと。</dd>
   * <dd>conditionの検索終了月がnullでないこと。</dd>
   * <dd>検索開始年と検索開始月によって指定される検索開始年月が日付として正しいこと。例えば検索開始年=2008、検索開始月=13の場合、検索開始年月は2008年13月となり日付として正しくありません。
   * <dd>検索終了年と検索終了月によって指定される検索終了年月が日付として正しいこと。例えば検索終了年=2008、検索終了月=13の場合、検索終了年月は2008年13月となり日付として正しくありません。
   * <dd>並べ替えタイプがnullでないこと。</dd>
   * <dd>上記いずれかに反している場合、データベースアクセスを行わず空のリストを返します。</dd>
   * </dd>
   * </dl>
   * </p>
   * <p>
   * <dl>
   * <dt><b>事後条件: </b></dt>
   * <dd>ありません。</dd>
   * </dl>
   * </p>
   * 
   * @param condition
   *          検索条件です。検索開始年、検索開始月、検索終了年、検索終了月、ショップコード、顧客グループコード、検索開始年齢、検索終了年齢、性別、並べ替えタイプの各フィールドを持ちます。
   *          並べ替え順は購入商品数累計の降順、受注回数の降順、商品コードの昇順のいずれかになります。
   * @return 集計結果です。各要素はショップコード、ショップ名、商品コード、商品名、顧客数合計、受注件数合計、受注件数構成率、購入商品数合計の各フィールドを持ちます。
   */
  SearchResult<CustomerPreferenceSummary> getCustomerPreference(CustomerPreferenceSearchCondition condition);

  /**
   * 直近1週間分の会員登録数をクライアントグループ毎に取得します。
   * <p>
   * <dl>
   * <dt><b>処理概要: </b></dt>
   * <dd>直近1週間分の会員登録数をクライアントグループ毎に取得します。
   * <ol>
   * <li>顧客テーブルを検索し、登録日時がシステム日付の1週間前からシステム日付の間である顧客を検索し
   * 登録日、クライアントグループごとに顧客数を集計します。</li>
   * <li>1．で集計した結果のリストを返します。</li>
   * </ol>
   * </dd>
   * </dl>
   * </p>
   * <p>
   * <dl>
   * <dt><b>前提条件: </b></dt>
   * <dd>ありません。</dd>
   * </dl>
   * </p>
   * <p>
   * <dl>
   * <dt><b>事後条件: </b></dt>
   * <dd>直近1週間分の会員登録数のリストを返します。</dd>
   * </dl>
   * </p>
   * 
   * @return 顧客登録数集計結果です。登録日付とクライアントグループを渡すことで対応するデータを返します。データが存在しない場合は顧客数が0であるデータを作成し返します。
   */
  WeekGraphData getCustomerRegisterLogWeek();

  /**
   * 顧客分析を行った結果を返します。
   * <p>
   * <dl>
   * <dt><b>処理概要: </b></dt>
   * <dd>顧客分析を行った結果を返します。
   * <ol>
   * <li>顧客分析テーブルを検索し、分析グループ、分析アイテムごとに顧客数を集計します。</li>
   * <li>1.で求めたデータのリストを返します。</li>
   * </ol>
   * </dd>
   * </dl>
   * </p>
   * <p>
   * <dl>
   * <dt><b>前提条件: </b></dt>
   * <dd>ありません。</dd>
   * </dl>
   * </p>
   * <p>
   * <dl>
   * <dt><b>事後条件: </b></dt>
   * <dd>ありません。</dd>
   * </dl>
   * </p>
   * 
   * @return 顧客分析テーブルテーブル内の全てのレコードを検索し集計した結果です。
   *         各要素はID、分析グループ、分析アイテム、顧客数の各フィールドをもちます。
   */
  List<CustomerStatisticsSummary> getCustomerStatistics();

  /**
   * 直近1週間分の受注件数をクライアントグループ毎に取得します。
   * <p>
   * <dl>
   * <dt><b>処理概要: </b></dt>
   * <dd>直近1週間分の受注件数をクライアントグループ毎に取得します。
   * <ol>
   * <li>引数のnullチェックを行います。nullであった場合は空のリストを返します。</li>
   * <li>受注ヘッダテーブルを検索し、受注日がシステム日付の1週間前からシステム日付の間である受注を検索し、受注日、クライアントグループごと受注件数を集計します。</li>
   * <li>1．で集計した結果のリストを返します。</li>
   * </ol>
   * </dd>
   * </dl>
   * </p>
   * <p>
   * <dl>
   * <dt><b>前提条件: </b></dt>
   * <dd>shopCodeがnullでないこと。</dd>
   * </dl>
   * </p>
   * <p>
   * <dl>
   * <dt><b>事後条件: </b></dt>
   * <dd>ありません。</dd>
   * </dl>
   * </p>
   * 
   * @param shopCode
   *          検索対象のショップコードです。
   * @return 直近1週間分の受注件数のリストです。各要素は集計日、クライアントグループ、受注件数の各フィールドを持ちます。
   */
  WeekGraphData getOrderCountLogWeek(String shopCode);

  /**
   * 直近1週間分のページビュー数をクライアントグループ毎に取得します。
   * <p>
   * <dl>
   * <dt><b>処理概要: </b></dt>
   * <dd>直近1週間分のページビュー数をクライアントグループ毎に取得します。
   * <ol>
   * <li>アクセスログテーブルを検索し、アクセス日がシステム日付の1週間前からシステム日付の間であるログを検索し、ページビューをアクセス日、クライアントグループごとに集計します。</li>
   * <li>1．で集計した結果のリストを返します。</li>
   * </dd>
   * </dl>
   * </p>
   * <p>
   * <dl>
   * <dt><b>前提条件: </b></dt>
   * <dd>ありません。</dd>
   * </dl>
   * </p>
   * <p>
   * <dl>
   * <dt><b>事後条件: </b></dt>
   * <dd>ありません。</dd>
   * </dl>
   * </p>
   * 
   * @return 直近1週間分のページビュー数のリストです。各要素は集計日、クライアントグループ、ページビュー数の各フィールドを持ちます。
   */
  WeekGraphData getPageViewLogWeek();

  /**
   * 検索条件を指定してリファラーの集計を行います。
   * <p>
   * <dl>
   * <dt><b>処理概要: </b></dt>
   * <dd>引数で指定された検索条件を満たすリファラーテーブルのレコードを検索し、集計した結果を返します。
   * <ol>
   * <li>検索条件のバリデーションチェックを行います。バリデーションエラーの場合は空のリストを返します。</li>
   * <li>リファラテーブルを検索し、アクセス日がconditionの検索開始日から検索終了日の間であり、
   * クライアントグループが検索条件で指定されたクライアントグループであるレコードを検索し、 リファラーURLごとにリファラー集計件数を集計します。
   * </li>
   * <li2.で集計した結果を返します。</li>
   * </ol>
   * </dd>
   * </dl>
   * </p>
   * <p>
   * <dl>
   * <dt><b>前提条件: </b></dt>
   * <dd>conditionがnullでないこと。</dd>
   * <dd>conditionの検索開始日がnullでないこと。</dd>
   * <dd>conditionの検索終了日がnullでないこと。</dd>
   * <dd>conditionのクライアントグループがnullでないこと。</dd>
   * </dl>
   * </p>
   * <p>
   * <dl>
   * <dt><b>事後条件: </b></dt>
   * <dd>ありません。</dd>
   * </dl>
   * </p>
   * 
   * @param condition
   *          検索条件です。検索開始日、検索終了日、クライアントグループの各フィールドを持ちます。
   * @return リファラー集計を行った結果のリストです。各要素はリファラーURLとリファラー集計件数の各フィールドを持ちます。
   */
  SearchResult<RefererSummary> getReferer(RefererSearchCondition condition);

  /**
   * 指定された条件でのRFM分析結果を返します。
   * <p>
   * <dl>
   * <dt><b>処理概要: </b></dt>
   * <dd>指定された条件でのRFM分析結果を返します。
   * <ol>
   * <li>検索条件のバリデーションチェックを行います。バリデーションエラーである場合は、空の結果を返します。</li>
   * <li> R、F、Mの条件をそれぞれ以下のように定めます。
   * <dl>
   * <dt> [R]ecency･･･最終受注日からの経過日数 </dt>
   * <dd> 最終受注日からの経過日数がRAの閾値以下の顧客をRA、RAの閾値からRBの閾値までの顧客をRB、それ以外の顧客をRCとします。 </dd>
   * </dl>
   * <dl>
   * <dt> [F]requency･･･最近の購入回数 </dt>
   * <dd>
   * システム日付からFの集計期間月前までの購入回数がFAの閾値以上の顧客をFA、FAの閾値からFBの閾値までの顧客をFB、それ以外の顧客をFCとします。
   * </dd>
   * </dl>
   * <dl>
   * <dt> [M]onetary･･･最近の購入金額 </dt>
   * <dd>
   * システム日付からMの集計期間月前までの累計購入金額がMAの閾値以上の顧客をMA、MAの閾値からMBの閾値までの顧客をMB、それ以外の顧客をMCとします。
   * </dd>
   * </dl>
   * </li>
   * <li>RFMテーブルを検索し、RF、RM、FM分析をそれぞれ行います。
   * <dl>
   * <dt> RF分析 </dt>
   * <dd>
   * RのランクとFのランクそれぞれによって分割されたブロックごとに、顧客数合計、顧客構成率、平均購入回数、購入回数構成率、平均購入商品数、購入商品数構成率、購入商品数構成率
   * 、Fのランク、Mのランクを計算します。 </dd>
   * </dl>
   * <dl>
   * <dt> RM分析 </dt>
   * <dd> RのランクとMのランクそれぞれによって分割されたブロックごとに、顧客数合計、顧客構成率、累計購入金額、購入金額構成率、Rのランク、M
   * のランクを計算します。 </dd>
   * </dl>
   * <dl>
   * <dt> FM分析 </dt>
   * <dd>
   * FのランクとMのランクそれぞれによって分割されたブロックごとに、顧客数合計、顧客構成率、平均購入商品数、購入商品数構成率、平均購入回数、購入回数構成率、平均購入商品数、購入商品数構成率、累計購入金額、Rのランク、Fのランクを計算します。
   * </dd>
   * </dl>
   * </li>
   * <li>3.で求めたRF、RM、FMの各分析結果をRfmDataに格納します。</li>
   * <li>4.で求めた結果を返します。</li>
   * </ol>
   * </dd>
   * </dl>
   * </p>
   * <p>
   * <dl>
   * <dt><b>前提条件: </b></dt>
   * <dd>conditionのRAの閾値がnullでないこと。</dd>
   * <dd>conditionのRBの閾値がnullでないこと。</dd>
   * <dd>conditionのFの集計期間がnullでないこと。</dd>
   * <dd>conditionのFAの閾値がnullでないこと。</dd>
   * <dd>conditionのFBの閾値がnullでないこと。</dd>
   * <dd>conditionのMの集計期間がnullでないこと。</dd>
   * <dd>conditionのMAの閾値がnullでないこと。</dd>
   * <dd>conditionのMBの閾値がnullでないこと。</dd>
   * <dd>上記のいずれかに反している場合、空のRfmAnalysisDataを作成して返します。</dd>
   * </dl>
   * </p>
   * <p>
   * <dl>
   * <dt><b>事後条件: </b></dt>
   * <dd>RFM分析を行い、RF、RM、FM分析の結果を1つのクラスにまとめて返します。</dd>
   * </dl>
   * </p>
   * 
   * @param condition
   *          分析条件です。RAの閾値、RBの閾値、Fの集計期間、FAの閾値、FBの閾値、Mの集計期間、MAの閾値、MBの閾値の各フィールドを持ちます。
   * @return RFM分析結果です。RF分析結果、RM分析結果、FM分析結果の各リストを持ちます。
   */
  RfmAnalysisData getRfmAnalysis(RfmAnalysisSearchCondition condition);

  /**
   * 指定した期間、集計単位の売上集計を行った結果を返します。
   * <p>
   * <dl>
   * <dt><b>処理概要: </b></dt>
   * <dd>指定した期間、集計単位の売上集計結果を返します。
   * <ol>
   * <li>検査軸条件のバリデーションチェックを行います。バリデーションエラーとなった場合は空のリストを返します。</li>
   * <li> 検索条件を以下のように定めます。
   * <ul>
   * <li>typeがDAILYである場合は集計単位は日別で、集計期間はyearとmonthで指定される月。</li>
   * <li>typeがMONTHLYである場合は集計単位は月別で、集計期間はyearによって指定される年。</li>
   * <li>shopCodeがnullである場合は全ショップ、nullでない場合は指定されたショップ。存在しないショップコードを指定した場合結果は空のリストになる。
   * </li>
   * </ul>
   * </li>
   * <li>2．で定めた検索条件を元にショップ別売上集計テーブルを検索し、売上金額、返金額、返金損金額、注文件数、返品件数、支払い手数料、送料、ギフト金額を集計します。</li>
   * <li>3．で求めた結果のリストを返します。</li>
   * </ol>
   * </dd>
   * </dl>
   * </p>
   * <p>
   * <dl>
   * <dt><b>前提条件: </b></dt>
   * <dd>検索条件がnullでないこと。</dd>
   * <dd>conditionの検索年がnullでないこと。</dd>
   * <dd>conditionのクライアントグループがnullでないこと。</dd>
   * <dd>conditionのcountTypeがnullでないこと。</dd>
   * <dd>conditionのcountTypeがDAILYであった場合、conditionの検索月がnullでないこと。</dd>
   * </dl>
   * </p>
   * <p>
   * <dl>
   * <dt><b>事後条件: </b></dt>
   * <dd>売上金額、返金額、返金損金額、注文件数、返品件数、支払い手数料、送料、ギフト金額を集計した結果を返します。</dd>
   * </dl>
   * </p>
   * 
   * @param condition
   *          検索条件です。検索年、検索月、ショップコード、クライアントグループ、支払い方法コード、集計単位の各フィールドを持ちます。
   * @return 全てのショップの売上げ集計結果です。各要素はショップ名、ショップコード、商品コード、SKUコード、規格別商品名称、売上金額累計、返金額累計、注文個数累計、返品個数累計、ギフト金額累計の各フィールドを持ちます。
   */
  List<SalesAmountByShopSummary> getSalesAmountByShop(SalesAmountByShopSearchCondition condition);
  
  List<NewPublicCouponSummary> getNewPublicCoupon(NewPublicCouponSearchCondition condition);

  /**
   * 検索条件を指定してSKU別売上集計を行った結果を返します。
   * <p>
   * <dl>
   * <dt><b>処理概要: </b></dt>
   * <dd>指定された検索条件からSKU別売上集計を行った結果を返します。
   * <ol>
   * <li>検索条件のバリデーションチェックを行います。バリデーションエラーの場合は空のリストを返します。</li>
   * <li>SKU別売上集計テーブルを参照し、集計日が検索条件で指定された期間内で、 ショップコードが検索条件で指定されたショップコードであり、
   * 商品コードが検索条件で指定された範囲内かつ検索条件で指定されたSKU名と部分一致するレコードについて
   * ショップ名、ショップコード、商品コード、SKUコード、SKU名ごとに売上金額累計、注文個数累計、返品個数累計、 ギフト金額累計をそれぞれ集計します。
   * </li>
   * <li>2.で集計した結果を返します。</li>
   * </ol>
   * </dd>
   * </dl>
   * </p>
   * <p>
   * <dl>
   * <dt><b>前提条件: </b></dt>
   * <dd>conditionがnullでないこと。</dd>
   * </dl>
   * </p>
   * <p>
   * <dl>
   * <dt><b>事後条件: </b></dt>
   * <dd>ありません。</dd>
   * </dl>
   * </p>
   * 
   * @param condition
   *          検索条件です。検索開始日、検索終了日、ショップコード、検索開始商品コード、検索終了商品コード、SKU名no 各フィールドを持ちます。
   * @return SKU別売上集計結果のリストです。各要素はショップ名、ショップコード、商品コード、コード、規格別商品名称、売上金額累計、返金額累計、注文個数累計、返品個数累計、ギフト金額累計の各フィールドを持ちます。
   */
  SearchResult<SalesAmountBySkuSummary> getSalesAmountBySku(SalesAmountBySkuSearchCondition condition);
  
  SearchResult<GiftCardUseLogSummary> getGiftCardUseLogList(GiftCardUseLogSearchCondition condition);

  /**
   * 指定した期間のショップごとの売上集計を返します。
   * <p>
   * <dl>
   * <dt><b>処理概要: </b></dt>
   * <dd>指定した期間のショップごとの売上集計を返します。
   * <ol>
   * <li>検索条件のバリデーションチェックを行います。バリデーションエラーの場合は空のリストを返します。</li>
   * <li>ショップ別売上集計テーブルの指定された期間のショップコードごとの売上金額、返金額、返金損金額、注文件数、返品件数、支払い手数料、送料、ギフト金額を集計します。</li>
   * <li>2．で求めた結果のリストを返します。</li>
   * </ol>
   * </dd>
   * </dl>
   * </p>
   * <p>
   * <dl>
   * <dt><b>前提条件: </b></dt>
   * <dd>rangeがnullでないこと。</dd>
   * <dd>rangeの開始日、終了日のうち、少なくとも1つはnullでないこと。</dd>
   * </dl>
   * </p>
   * <p>
   * <dl>
   * <dt><b>事後条件: </b></dt>
   * <dd>ありません。</dd>
   * </dl>
   * </p>
   * 
   * @param range
   *          検索する日付の範囲です。
   * @return ショップごとの売上げ集計結果です。各要素はショップ名、ショップコード、商品コード、SKUコード、規格別商品名称、売上金額累計、返金額累計、注文個数累計、返品個数累計、ギフト金額累計の各フィールドを持ちます。
   */
  List<SalesAmountSummary> getSalesAmountShop(DateRange range);

  /**
   * 指定した期間のサイト全体の売上集計を返します。
   * <p>
   * <dl>
   * <dt><b>処理概要: </b></dt>
   * <dd>指定した期間のサイトの売上集計を返します。
   * <ol>
   * <li>検索条件のバリデーションチェックを行います。バリデーションエラーである場合は空の結果を返します。
   * <li>ショップ別売上集計テーブルの指定された期間の売上金額、返金額、返金損金額、注文件数、返品件数、支払い手数料、送料、ギフト金額を集計します。</li>
   * <li>2．で求めた結果のリストを返します。</li>
   * </ol>
   * </dd>
   * </dl>
   * </p>
   * <p>
   * <dl>
   * <dt><b>前提条件: </b></dt>
   * <dd>rangeがnullでないこと。</dd>
   * <dd>rangeの開始日、終了日のうち、少なくとも1つはnullでないこと。</dd>
   * <dd>上記のいずれかに反する場合は空のリストを返します。</dd>
   * </dl>
   * </p>
   * <p>
   * <dl>
   * <dt><b>事後条件: </b></dt>
   * <dd>ありません。</dd>
   * </dl>
   * </p>
   * 
   * @param period
   *          検索する日付の範囲です。
   * @return 全てのショップの売上げ集計結果です。各要素はショップ名、ショップコード、商品コード、SKUコード、規格別商品名称、売上金額累計、返金額累計、注文個数累計、返品個数累計、ギフト金額累計の各フィールドを持ちます。
   *         集計したレコードが存在しない場合は売上金額累計、返金額累計、返品損金額累計、注文件数累計、返品件数累計、値引額累計、
   *         使用ポイント累計、発行ポイント累計、支払手数料累計、送料累計、ギフト金額累計がいずれも0であるデータを作成し返します。
   */
  SalesAmountSummary getSalesAmountSite(DateRange period);

  /**
   * 検索キーワードログテーブルから検索キーのリストを取得します。
   * <p>
   * <dl>
   * <dt><b>処理概要: </b></dt>
   * <dd>検索キーワードログテーブルから検索キーのリストを取得します。
   * <ol>
   * <li>検索キーワードログテーブルから検索キーを重複を許さず取得します。</li>
   * <li>取得したデータのリストを返します。</li>
   * </ol>
   * </dd>
   * </dl>
   * </p>
   * <p>
   * <dl>
   * <dt><b>前提条件: </b></dt>
   * <dd>ありません。</dd>
   * </dl>
   * </p>
   * <p>
   * <dl>
   * <dt><b>事後条件: </b></dt>
   * <dd>ありません。</dd>
   * </dl>
   * </p>
   * 
   * @return 検索キーのリストです。
   */
  List<String> getSearchKey();

  /**
   * 検索条件に該当する検索キーワード集計結果のリストを返します。
   * <p>
   * <dl>
   * <dt><b>処理概要: </b></dt>
   * <dd>検索条件によって検索キーワードログを集計した結果のリストを返します。
   * <ol>
   * <li>検索条件のバリデーションチェックを行います。バリデーションエラーの場合は空のリストを返します。</li>
   * <li>検索キーワードログテーブルの検索日が検索条件の検索開始日から検索終了日の間であり
   * 検索キーが検索条件の検索キーと一致するレコードについて検索回数を集計します。</li>
   * <li>2.で求めた結果を返します。</li>
   * </ol>
   * </dd>
   * </dl>
   * </p>
   * <p>
   * <dl>
   * <dt><b>前提条件: </b></dt>
   * <dd>conditionがnullでないこと。</dd>
   * <dd>conditionの検索開始日と検索終了日が共にnullでない場合、 検索開始日<=検索終了日であること。 </dd>
   * </dl>
   * </p>
   * <p>
   * <dl>
   * <dt><b>事後条件: </b></dt>
   * <dd>ありません。</dd>
   * </dl>
   * </p>
   * 
   * @param condition
   *          検索条件です。検索開始日、検索終了日、検索キーの各フィールドを持ちます。
   * @return 検索キーワードログを検索し集計した結果です。検索キー、検索ワード、検索回数の各フィールドを持ちます。
   */
  SearchResult<SearchKeywordLogSummary> getSearchKeywordLog(SearchKeywordLogSearchCondition condition);

  /**
   * ストリームからアクセスログを読み込み、アクセスログのデータを作成します。
   * <p>
   * <dl>
   * <dt><b>処理概要: </b></dt>
   * <dd>ストリームからページビューログ、ビジットログを読み込み、アクセスログのデータを作成します。
   * <ol>
   * <li>引数で指定されたアクセスログ読み込み用ストリームがnullでないことをチェックします。nullである場合はサービス処理結果にVALIDATION_ERRORを設定します。</li>
   * <li>引数で指定されたアクセスログ読み込み用ストリームがreadyであることをチェックします。readyでなかった場合はサービス処理結果にVALIDATION_ERRORを設定します。</li>
   * <li>readerからビジットログのデータを読み込みます。</li>
   * <li>読み込んだデータをアクセス日、アクセス時間帯、クライアントグループごとに集計しユニークsessionID数からビジット数を求めます。</li>
   * <li>読み込んだデータをアクセス日、アクセス時間帯、クライアントグループごとに集計し、ページビュー数を求めます。</li>
   * <li>4.と6.で求めたデータをマージします。</li>
   * <li>アクセスログテーブルの7.で求めたデータと同じアクセス日、アクセス時間帯、クライアントグループを持つレコードをDELETEします。</li>
   * <li>アクセスログテーブルに7.で求めたデータをINSERTします。</li>
   * <li>トランザクションをCOMMITしサービス処理結果を返します。</li>
   * </dd>
   * </dl>
   * </p>
   * <p>
   * <dl>
   * <dt><b>前提条件: </b></dt>
   * <dd>readerがnullでないこと。</dd>
   * <dd>readerがreadyであること。</dd>
   * </dl>
   * </p>
   * <p>
   * <dl>
   * <dt><b>事後条件: </b></dt>
   * <dd>ストリームから読み込んだデータを元にアクセスログテーブルが更新されます。</dd>
   * <dd>ビジットログ、ページビューログの規定の書式に従っていない行については読み込みがスキップされます。</dd>
   * <dd>規定の書式は以下の通りです。
   * <dl>
   * <dt> アクセスログ </dt>
   * <dd> 日付(yyyy/MM/dd),時刻(HH:mm:ss),セッションID,ユーザーエージェント文字列 </dd>
   * </dl>
   * </dd>
   * <dd>データベースアクセス中の例外が発生した場合はトランザクションをROLLBACKしサービス処理結果にDB_OBJECT_EXECUTE_ERRORを設定し返します。</dd>
   * </dl>
   * </p>
   * 
   * @param reader
   *          アクセスログ読み込み用ストリームです。このメソッドが実行された後クローズされます。
   * @return サービス処理結果です。
   */
  ServiceResult importAccessLog(Reader reader);

  /**
   * ストリームから商品別アクセスログを読み込み、商品別アクセスログのデータを作成します。
   * <p>
   * <dl>
   * <dt><b>処理概要: </b></dt>
   * <dd>ストリームから商品別アクセスログを読み込み、商品別アクセスログのデータを作成します。
   * <ol>
   * <li>引数で指定された商品別アクセスログ読み込み用ストリームがnullでないことをチェックします。nullであった場合はサービス処理結果にVALIDATION_ERRORを設定します。</li>
   * <li>引数で指定された商品別アクセスログ読み込み用ストリームがreadyであることをチェックします。readyでなかった場合はサービス処理結果にVALIDATION_ERRORを設定します。</li>
   * <li>引数で指定されたreaderから商品別アクセスログのログを読み込みます。</li>
   * <li>読み込んだデータをアクセス日、ショップコード、商品コード、クライアントグループごとに集計し、アクセス回数を求めます。</li>
   * <li>4.で求めたデータのショップコードでショップテーブルを検索しショップ名を取得します。指定のショップコードを持つショップのレコードが存在しない場合はそのデータを削除します。</li>
   * <li>4.で求めたデータのショップコード、商品コードで商品ヘッダテーブルを検索し商品名を取得します。指定のショップコードと商品コードを持つ商品のレコードが存在しない場合はそのデータを削除します。</li>
   * <li>4.で求めたデータと5.、6.で求めたデータをマージします。</li>
   * <li>7.で求めたデータと同じアクセス日、ショップコード、商品コードを持つレコードを検索キーワードログテーブルからDELETEします。</li>
   * <li>7.で求めたデータを商品別アクセスログテーブルにINSERTします。</li>
   * <li>トランザクションをCOMMITし、サービス処理結果を返します。</li>
   * </ol>
   * </dd>
   * </dl>
   * </p>
   * <p>
   * <dl>
   * <dt><b>前提条件: </b></dt>
   * <dd>readerがnullでないこと。</dd>
   * <dd>readerがreadyであること。</dd>
   * </dl>
   * </p>
   * <p>
   * <dl>
   * <dt><b>事後条件: </b></dt>
   * <dd>ストリームから読み込んだデータを元に商品別アクセスログ(COMMODITY_ACCESS_LOG)テーブルが更新されます。</dd>
   * <dd>商品別アクセスログの規定の書式に従っていない行については読み込みがスキップされます。</dd>
   * <dd>規定の書式は以下の通りです。</dd>
   * <dl>
   * <dt> 商品別アクセスログ </dt>
   * <dd> 日付(yyyy/MM/dd),ショップコード,商品コード,エージェント文字列</dd>
   * <dd>存在しないショップのショップコード、存在しないクライアントグループが記述された行についてはカウントを行わずスキップします。</dd>
   * </dl>
   * <dd>データベースアクセス中の例外が発生した場合はトランザクションをROLLBACKしサービス処理結果にDB_OBJECT_EXECUTE_ERRORを設定し返します。</dd>
   * </dl>
   * </p>
   * 
   * @param reader
   *          検索キーワードログ読み込み用ストリームです。このメソッドが実行された後クローズされます。
   * @return サービス処理結果です。
   */
  ServiceResult importCommodityAccessLog(Reader reader);

  /**
   * ストリームからリファラーログを読み込み、リファラーログのデータを作成します。
   * <p>
   * <dl>
   * <dt><b>処理概要: </b></dt>
   * <dd>ストリームからリファラーログを読み込み、リファラーログのデータを作成します。
   * <ol>
   * <li>引数で指定されたリファラーログ読み込み用ストリームがnullでないことをチェックします。nullであった場合はサービス処理結果にVALIDATION_ERRORを設定します。</li>
   * <li>引数で指定されたリファラーログ読み込み用ストリームがreadyであることをチェックします。readyでなかった場合はサービス処理結果にVALIDATION_ERRORを設定します。</li>
   * <li>readerからリファラーのログを読み込みます。</li>
   * <li>読み込んだデータをアクセス日、クライアントグループ、リファラーURLごとに集計し、リファラー回数を求めます。</li>
   * <li>4.で求めたデータと同じアクセス日、クライアントグループを持つレコードをリファラーテーブルからDELETEします。</li>
   * <li>4.で求めたデータをリファラーテーブルにINSERTします。</li>
   * <li>トランザクションをCOMMITし、サービス処理結果を返します。</li>
   * </ol>
   * </dd>
   * </dl>
   * </p>
   * <p>
   * <dl>
   * <dt><b>前提条件: </b></dt>
   * <dd>readerがnullでないこと。</dd>
   * <dd>readerがreadyであること。</dd>
   * </dl>
   * </p>
   * <p>
   * <dl>
   * <dt><b>事後条件: </b></dt>
   * <dd>ストリームから読み込んだデータを元にリファラーテーブルが更新されます。</dd>
   * <dd>リファラーログの規定の書式に従っていない行については読み込みがスキップされます。</dd>
   * <dd>規定の書式は以下の通りです。</dd>
   * <dl>
   * <dt> リファラーログ </dt>
   * <dd> 日付(yyyy/MM/dd),リファラーURL,ユーザーエージェント文字列 </dd>
   * </dl>
   * <dd>データベースアクセス中の例外が発生した場合はトランザクションをROLLBACKしサービス処理結果にDB_OBJECT_EXECUTE_ERRORを設定し返します。</dd>
   * </dl>
   * </p>
   * 
   * @param reader
   *          リファラログ読み込み用ストリームです。このメソッドが実行された後クローズされます。
   * @return サービス処理結果です。
   */
  ServiceResult importReferer(Reader reader);

  /**
   * DBに登録されているアクセスログの最新アクセス日時を取得します。
   * <p>
   * <dl>
   * <dt><b>処理概要: </b></dt>
   * <dd>アクセスログテーブルに登録された最新のアクセスログ日時を取得します。
   * <ol>
   * <li>アクセスログテーブルの最もアクセス日が新しいレコードのうち、アクセス時刻が最も新しいものを取得します。</li>
   * <li>取得した日付、時刻からDate型の値を生成し返します。</li>
   * </ol>
   * </dd>
   * </dl>
   * </p>
   * <p>
   * <dl>
   * <dt><b>前提条件: </b></dt>
   * <dd>ありません。</dd>
   * </dl>
   * </p>
   * <p>
   * <dl>
   * <dt><b>事後条件: </b></dt>
   * <dd>アクセスログテーブルにレコードが１つもない場合はnullを返します。</dd>
   * </dl>
   * </p>
   * 
   * @return アクセスログのレコードの最新アクセス日時
   */
  Date getLatestAccessLogDate();

  /**
   * DBに登録されている商品別アクセスログの最新アクセス日を取得します。
   * <p>
   * <dl>
   * <dt><b>処理概要: </b></dt>
   * <dd>商品別アクセスログテーブルに登録された最新のアクセス日を取得します。
   * <ol>
   * <li>商品別アクセスログテーブルの最も新しいアクセス日を取得します。</li>
   * <li>取得したアクセス日を返します。</li>
   * </ol>
   * </dd>
   * </dl>
   * </p>
   * <p>
   * <dl>
   * <dt><b>前提条件: </b></dt>
   * <dd>ありません。</dd>
   * </dl>
   * </p>
   * <p>
   * <dl>
   * <dt><b>事後条件: </b></dt>
   * <dd>商品別アクセスログテーブルにレコードが１つもない場合はnullを返します。</dd>
   * </dl>
   * </p>
   * 
   * @return 商品別アクセスログのレコードの最新アクセス日
   */
  Date getLatestCommodityAccessLogDate();

  /**
   * DBに登録されているリファラログの最新アクセス日を取得します。
   * <p>
   * <dl>
   * <dt><b>処理概要: </b></dt>
   * <dd>リファラログテーブルに登録された最新のアクセス日を取得します。
   * <ol>
   * <li>リファラログテーブルの最も新しいアクセス日を取得します。</li>
   * <li>取得したアクセス日を返します。</li>
   * </ol>
   * </dd>
   * </dl>
   * </p>
   * <p>
   * <dl>
   * <dt><b>前提条件: </b></dt>
   * <dd>ありません。</dd>
   * </dl>
   * </p>
   * <p>
   * <dl>
   * <dt><b>事後条件: </b></dt>
   * <dd>リファラログテーブルにレコードが１つもない場合はnullを返します。</dd>
   * </dl>
   * </p>
   * 
   * @return リファラログのレコードの最新アクセス日
   */
  Date getLatestRefererLogDate();

  //postgres start
  void databaseAnalysis();
  //postgres end
  
  //soukai add ob 2011/12/21 start
  /**
   * 根据查询条件取得促销企划分析信息
   * 
   * @param condition 查询条件
   * 
   * @return 
   */
  SearchResult<PlanSummaryViewInfo> getPlanSummaryViewList(PlanSummaryViewSearchCondition condition);
  
  /**
   * 根据查询条件取得顾客组别优惠活动信息
   * 
   * @param condition 查询条件
   * 
   * @return 顾客组别优惠活动信息
   */
  SearchResult<CustomerGroupCampaignSummaryViewList> getCustomerGroupCampaignSummaryViewList(CustomerGroupCampaignSummaryViewSearchCondition condition);
  //soukai add ob 2011/12/21 end
}
